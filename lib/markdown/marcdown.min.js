MathJax.Hub.Config({
    skipStartupTypeset: true,
    showProcessingMessages: false,
    tex2jax: {
        inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
        ],
        displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
        ],
        processEscapes: true,
    },
    TeX: {
        equationNumbers: {
            autoNumber: "AMS",
        },
    },
});
marked.setOptions({
    smartLists: true,
    smartypants: true,
});
const Preview = {
    delay: 0,
    preview: null,
    buffer: null,
    timeout: null,
    mjRunning: false,
    oldText: null,
    Init() {
        this.preview = document.getElementById("viewer");
        this.buffer = document.getElementById("buffer");
        this.textarea = document.getElementById("getm");
        this.wordcount = document.getElementById("EDIT__wordcount");
        this.charcount = document.getElementById("EDIT__charcount");
    },
    SwapBuffers() {
        let buffer = this.preview;
        let preview = this.buffer;
        this.buffer = buffer;
        this.preview = preview;
        buffer.style.display = "none";
        preview.style.display = "flex";
    },
    Update() {
        if (this.timeout) {
            clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(this.callback, this.delay);
    },
    CreatePreview() {
        Preview.timeout = null;
        if (this.mjRunning) return;
        let text = this.textarea.value;
        if (text === this.oldtext) return;
        text = this.Escape(text);

        this.buffer.innerHTML = this.oldtext = text;
        this.mjRunning = true;

        MathJax.Hub.Configured();
        MathJax.Hub.Queue(
            ["Typeset", MathJax.Hub, this.buffer],
            ["PreviewDone", this]
            // ["resetEquationNumbers", MathJax.InputJax.TeX]
        );

        let viewer =
            document.getElementById("viewer").style.display == "none"
                ? document.getElementById("buffer")
                : document.getElementById("viewer");
        let regex = /\s+/gi;
        if (text !== "") {
            let wordCount = viewer.innerText.trim().replace(regex, " ").split(" ").length;
            let charCount = viewer.innerText.replace(regex, "").length;
            this.wordcount.innerHTML = `${wordCount} words`;
            this.charcount.innerHTML = `${charCount} chars`;
        } else {
            this.wordcount.innerHTML = "0 words";
            this.charcount.innerHTML = "0 chars";
        }
    },
    PreviewDone() {
        this.mjRunning = false;
        text = this.buffer.innerHTML;
        text = this.PartialDescape(text);
        this.buffer.innerHTML = marked(text);
        document.querySelectorAll("code").forEach((block) => {
            hljs.highlightBlock(block);
        });
        this.SwapBuffers();
    },
    Escape(html, encode) {
        return html
            .replace(!encode ? /&(?!#?\w+;)/g : /&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    },
    PartialDescape(html) {
        let lines = html.split("\n");
        let out = "";
        // is true when we are
        // ```
        //  inside a code block
        // ```
        let inside_code = false;
        for (let i = 0; i < lines.length; i++) {
            // a hack to properly rendre the blockquotes
            if (lines[i].startsWith("&gt;")) {
                lines[i] = lines[i].replace(/&gt;/g, ">");
            }
            // rendrer properly stuff like this
            // ```c
            //  if (a > b)
            // ```
            if (inside_code) {
                // inside the code we descape stuff
                lines[i] = lines[i]
                    .replace(/&lt;/g, "<")
                    .replace(/&gt;/g, ">")
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, "'");
            }
            if (lines[i].startsWith("```")) {
                inside_code = !inside_code;
            }
            out += `${lines[i]}\n`;
        }
        return out;
    },
    // The idea here is to perform fast updates.
    // See http://stackoverflow.com/questions/11228558/let-pagedown-and-mathjax-work-together/21563171?noredirect=1#comment46869312_21563171
    // But our implementation is a bit buggy: flickering, bad rendering when someone types very fast.
    //
    // If you want to enable such buggy fast updates, you should
    // add something like  onkeypress="Preview.UpdateKeyPress(event)" to textarea's attributes.
    UpdateKeyPress({ keyCode }) {
        if (keyCode < 16 || keyCode > 47) {
            this.preview.innerHTML = `<p>${marked(this.textarea.value)}</p>`;
            this.buffer.innerHTML = `<p>${marked(this.textarea.value)}</p>`;
        }
        this.Update();
    },
};

Preview.callback = MathJax.Callback(["CreatePreview", Preview]);
Preview.callback.autoReset = true;

// const addOperation = async() => {
//     let somethingPreview = await Preview.CreatePreview();
//     return somethingPreview;
//   }

//   const display = () => {
//      addOperation()
//         .then(data => console.log(data));

//   }

//   display();
Preview.Init();
Preview.Update();

const apply = (e) => {
    let myField = document.getElementById("getm");
    let myValueBefore;
    let myValueAfter;
    switch (e) {
        case "bold":
            myValueBefore = "**";
            myValueAfter = "**";
            break;
        case "italic":
            myValueBefore = "*";
            myValueAfter = "*";
            break;
        case "strike":
            myValueBefore = "~";
            myValueAfter = "~";
            break;
        case "h1":
            myValueBefore = "# ";
            myValueAfter = "";
            break;
        case "h2":
            myValueBefore = "## ";
            myValueAfter = "";
            break;
        case "h3":
            myValueBefore = "### ";
            myValueAfter = "";
            break;
        case "bq":
            myValueBefore = "> ";
            myValueAfter = "";
            break;
        case "ol":
            myValueBefore = "1. ";
            myValueAfter = "";
            break;
        case "ul":
            myValueBefore = "- ";
            myValueAfter = "";
            break;
        case "ic":
            myValueBefore = "`";
            myValueAfter = "`";
            break;
        case "bc":
            myValueBefore = "```\n";
            myValueAfter = "\n```";
            break;
        case "link":
            myValueBefore = "[";
            myValueAfter = "]()";
            break;
        case "check":
            myValueBefore = "- [x] ";
            myValueAfter = "";
            break;
        case "image":
            myValueBefore = "![alt text](imageLink)";
            myValueAfter = "";
            break;
        case "hr":
            myValueBefore = "---\n";
            myValueAfter = "";
            break;
        case "table":
            myValueBefore = "| Header | Title |\n| ----------- | ----------- |\n| Paragraph | Text |\n";
            myValueAfter = "";
            break;
    }
    if (document.selection) {
        myField.focus();
        document.selection.createRange().text = myValueBefore + document.selection.createRange().text + myValueAfter;
    } else if (myField.selectionStart || myField.selectionStart == "0") {
        let startPos = myField.selectionStart;
        let endPos = myField.selectionEnd;
        myField.value =
            myField.value.substring(0, startPos) +
            myValueBefore +
            myField.value.substring(startPos, endPos) +
            myValueAfter +
            myField.value.substring(endPos, myField.value.length);
        myField.selectionStart = startPos + myValueBefore.length;
        myField.selectionEnd = endPos + myValueBefore.length;
        myField.focus();
    }
    Preview.Update();
};

const slide = (e) => {
    let mark = document.getElementById("EDIT__textarea_left");
    let marktext = document.getElementById("getm");
    let viewer = document.getElementById("EDIT__textarea_right");
    switch (e) {
        case "nill":
            viewer.style.width = "100%";
            viewer.style.padding = "16px";

            marktext.style.padding = "0";
            mark.style.width = "0";
            break;
        case "half":
            viewer.style.width = "50%";
            viewer.style.padding = "16px";
            marktext.style.padding = "16px";
            marktext.style.width = "100%";
            mark.style.width = "50%";
            break;
            case "full":
                viewer.style.width = "0";
                viewer.style.padding = "0";
            mark.style.width = "100%";
            marktext.style.padding = "16px";
            marktext.style.width = "100%";
            break;
    }
};
